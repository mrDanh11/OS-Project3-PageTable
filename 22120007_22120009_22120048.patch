diff --git a/.gitignore b/.gitignore
index b803472..0ff2cbf 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
+<<<<<<< HEAD
 *~
 _*
 *.o
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..082b194
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,3 @@
+{
+    "makefile.configureOnOpen": false
+}
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 365c91b..16c3a34 100644
--- a/Makefile
+++ b/Makefile
@@ -188,6 +188,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_pgtbltest\
 
 
 
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..45eb8ed 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -173,6 +173,8 @@ uint64          walkaddr(pagetable_t, uint64);
 int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
+void            vmprint(pagetable_t pagetable);
+
 
 // plic.c
 void            plicinit(void);
diff --git a/kernel/exec.c b/kernel/exec.c
index e18bbb6..d699325 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -128,6 +128,11 @@ exec(char *path, char **argv)
   p->trapframe->sp = sp; // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
 
+  // vmprint
+  if (p->pid == 1) {
+    vmprint(p->pagetable); // In bảng trang của tiến trình Init
+}
+
   return argc; // this ends up in a0, the first argument to main(argc, argv)
 
  bad:
diff --git a/kernel/proc.c b/kernel/proc.c
index 58a8a0b..25a53bb 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -132,6 +132,13 @@ found:
     return 0;
   }
 
+  p->dia_chi_vung_nho_chia_se = (struct usyscall *)kalloc();
+    if (p->dia_chi_vung_nho_chia_se == 0) {
+        freeproc(p);  // Xử lý lỗi nếu không cấp phát được
+        release(&p->lock);
+        return 0;
+  }
+
   // An empty user page table.
   p->pagetable = proc_pagetable(p);
   if(p->pagetable == 0){
@@ -146,6 +153,7 @@ found:
   p->context.ra = (uint64)forkret;
   p->context.sp = p->kstack + PGSIZE;
 
+  p->dia_chi_vung_nho_chia_se->pid = p->pid;//Luu pid
   return p;
 }
 
@@ -169,6 +177,12 @@ freeproc(struct proc *p)
   p->killed = 0;
   p->xstate = 0;
   p->state = UNUSED;
+
+  //Giải phóng vùng nhớ chia sẻ
+    if (p->dia_chi_vung_nho_chia_se) {
+        kfree((void *)p->dia_chi_vung_nho_chia_se);
+    }
+    p->dia_chi_vung_nho_chia_se = 0;
 }
 
 // Create a user page table for a given process, with no user memory,
@@ -202,6 +216,14 @@ proc_pagetable(struct proc *p)
     return 0;
   }
 
+  if (mappages(pagetable, USYSCALL, PGSIZE,
+                 (uint64)p->dia_chi_vung_nho_chia_se, PTE_R | PTE_U) < 0) {
+    uvmunmap(pagetable, TRAPFRAME, 1, 0);  // Hủy ánh xạ TRAPFRAME
+    uvmunmap(pagetable, TRAMPOLINE, 1, 0); // Hủy ánh xạ TRAMPOLINE
+    uvmfree(pagetable, 0);
+    return 0;
+  }
+
   return pagetable;
 }
 
@@ -212,6 +234,7 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz)
 {
   uvmunmap(pagetable, TRAMPOLINE, 1, 0);
   uvmunmap(pagetable, TRAPFRAME, 1, 0);
+  uvmunmap(pagetable, USYSCALL, 1, 0); 
   uvmfree(pagetable, sz);
 }
 
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..734a605 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -99,9 +99,10 @@ struct proc {
   uint64 kstack;               // Virtual address of kernel stack
   uint64 sz;                   // Size of process memory (bytes)
   pagetable_t pagetable;       // User page table
+  struct usyscall* dia_chi_vung_nho_chia_se; // Luu dia chi vung nho chia se 
   struct trapframe *trapframe; // data page for trampoline.S
   struct context context;      // swtch() here to run process
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
-};
+};
\ No newline at end of file
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 20a01db..efbb6f5 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -343,6 +343,7 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PTE_W (1L << 2)
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // user can access
+#define PTE_A (1L << 6) // access bit
 
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 88644b2..14d3cad 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -71,12 +71,42 @@ sys_sleep(void)
 
 
 #ifdef LAB_PGTBL
-int
+
+  int
 sys_pgaccess(void)
 {
   // lab pgtbl: your code here.
+  uint64 virtual_addr, user_addr;
+  int pg_nums;
+  uint64 bitmask = 0;
+
+  argaddr(0, &virtual_addr);
+  argint(1, &pg_nums);
+  argaddr(2, &user_addr);
+
+  for(int i=0; i<pg_nums; i++){
+    uint64 pg_addr = virtual_addr + i*PGSIZE;
+
+    pte_t* pte = walk(myproc()->pagetable, pg_addr, 0);
+
+    if (!pte || !(*pte & PTE_V)) {
+      continue;  // Bỏ qua nếu PTE không hợp lệ
+    }
+
+    if (*pte & PTE_A){ // Kiểm tra access bit có được bật hay không?
+      bitmask = bitmask | (1 << i); // Bật bit thứ i trong bitmask để đánh dấu trang này đã được truy cập
+      *pte = *pte & (~PTE_A); // Tắt bit PTE_A
+    }
+  }
+
+  if (copyout(myproc()->pagetable, user_addr, (char*)&bitmask, sizeof(bitmask)) < 0) {
+    return -1; 
+  }
+
   return 0;
 }
+
+
 #endif
 
 uint64
diff --git a/kernel/vm.c b/kernel/vm.c
index 5c31e87..bb939c5 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -449,3 +449,29 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
     return -1;
   }
 }
+
+// vmprint
+void vmprint(pagetable_t pagetable) {
+    printf("page table %p\n", pagetable); // In địa chỉ bảng trang gốc
+
+    // Hàm đệ quy để in từng mục PTE
+    void printpte(pagetable_t pt, int level) {
+        for (int i = 0; i < 512; i++) {
+            pte_t pte = pt[i];
+            if (pte & PTE_V) { // Chỉ in mục hợp lệ
+                uint64 pa = PTE2PA(pte); // Lấy địa chỉ vật lý
+                for (int j = 0; j < level; j++) // Dấu ".." theo cấp độ
+                    printf(" ..");
+                printf("%d: pte %p pa %p\n", i, pte, pa);
+
+                // Nếu đây là bảng trang cấp thấp hơn
+                if ((pte & (PTE_R | PTE_W | PTE_X)) == 0) {
+                    pagetable_t child = (pagetable_t)pa;
+                    printpte(child, level + 1); // Đệ quy in tiếp
+                }
+            }
+        }
+    }
+
+    printpte(pagetable, 1); // Bắt đầu in từ cấp 1
+}
\ No newline at end of file
diff --git a/user/pgaccess.c b/user/pgaccess.c
new file mode 100644
index 0000000..d112ca0
--- /dev/null
+++ b/user/pgaccess.c
@@ -0,0 +1,6 @@
+#include "user.h"
+#include "kernel/syscall.h"
+
+int pgaccess(void *base, int len, void *mask){
+    return syscall(SYS_pgaccess, base, len, mask);
+}
\ No newline at end of file
